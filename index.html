<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>‡§ï‡§ø‡§∏‡§æ‡§® ‡§Æ‡§ø‡§§‡•ç‡§∞ - Crop Predictor | ‡§ï‡•É‡§∑‡§ø ‡§∏‡§≤‡§æ‡§π‡§ï‡§æ‡§∞</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        /* (original CSS preserved exactly as provided by you) */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
            position: relative;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .language-toggle {
            position: absolute;
            top: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 25px;
            padding: 10px 20px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .language-toggle:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .main-card {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0;
            min-height: 600px;
        }

        .input-section {
            padding: 40px;
            background: linear-gradient(145deg, #f8f9ff, #e8ecff);
            border-right: 1px solid #e0e0e0;
        }

        .output-section {
            padding: 40px;
            background: linear-gradient(145deg, #fff8f0, #f0f8ff);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .form-group {
            margin-bottom: 25px;
        }

        .form-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
            font-size: 1.1rem;
        }

        .bilingual {
            color: #666;
            font-size: 0.9rem;
            font-weight: normal;
        }

        .form-control {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 1rem;
            transition: all 0.3s ease;
            background: white;
        }

        .form-control:focus {
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            outline: none;
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .predict-btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.2rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .predict-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(255, 107, 107, 0.3);
        }

        .predict-btn:active {
            transform: translateY(0);
        }

        .results-container {
            text-align: center;
            width: 100%;
        }

        .result-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
            border-left: 5px solid #4CAF50;
            animation: slideIn 0.5s ease;
        }

        .result-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .result-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #4CAF50;
            margin-bottom: 5px;
        }

        .result-subtitle {
            color: #666;
            font-size: 0.9rem;
        }

        .empty-state {
            opacity: 0.7;
        }

        .empty-state i {
            font-size: 4rem;
            color: #ddd;
            margin-bottom: 20px;
        }

        .empty-state p {
            color: #999;
            font-size: 1.1rem;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .loading {
            display: none;
            text-align: center;
            padding: 40px;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .main-card {
                grid-template-columns: 1fr;
                gap: 0;
            }
            
            .form-row {
                grid-template-columns: 1fr;
                gap: 15px;
            }

            .header h1 {
                font-size: 2rem;
            }

            .input-section, .output-section {
                padding: 25px;
            }

            .language-toggle {
                position: static;
                margin-bottom: 20px;
                display: inline-flex;
            }
        }

        .info-tooltip {
            position: relative;
            display: inline-block;
            margin-left: 5px;
            color: #667eea;
            cursor: help;
        }

        .tooltip-text {
            visibility: hidden;
            width: 200px;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            font-size: 0.8rem;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .info-tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        .hidden {
            display: none !important;
        }

        /* Simple notification styles */
        .notification {
            display: inline-block;
        }

        /* gauge specific small helpers */
        .gauge-wrapper {
            width: 100%;
            max-width: 420px;
            margin: 10px auto 20px;
        }
        .probability-card {
            margin-top: 10px;
        }
        .gauge-labels {
            display:flex;
            justify-content:space-between;
            margin-top:8px;
            font-size:0.9rem;
            color:#666;
        }

        /* NPK gauges container */
        .npk-gauges {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 12px;
        }
        .npk-gauge {
            width: 30%;
            min-width: 180px;
            text-align: center;
        }
        .npk-meta {
            margin-top: 8px;
            font-size: 0.9rem;
            color: #555;
        }
        @media (max-width: 900px) {
            .npk-gauge { width: 45%; }
        }
        @media (max-width: 480px) {
            .npk-gauge { width: 100%; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="language-toggle" id="languageToggle" role="button" aria-pressed="false" tabindex="0">
                <i class="fas fa-language" aria-hidden="true"></i>
                <span id="langText">‡§π‡§ø‡§Ç‡§¶‡•Ä</span>
            </div>
            <h1><i class="fas fa-seedling"></i> <span id="mainTitle">‡§ï‡§ø‡§∏‡§æ‡§® ‡§Æ‡§ø‡§§‡•ç‡§∞ - Crop Predictor</span></h1>
            <p id="subtitle">‡§Ü‡§™‡§ï‡•Ä ‡§´‡§∏‡§≤ ‡§ï‡•Ä ‡§≠‡§µ‡§ø‡§∑‡•ç‡§Ø‡§µ‡§æ‡§£‡•Ä ‡§ï‡§∞‡§®‡•á ‡§µ‡§æ‡§≤‡§æ ‡§∏‡•ç‡§Æ‡§æ‡§∞‡•ç‡§ü ‡§∏‡§≤‡§æ‡§π‡§ï‡§æ‡§∞</p>
        </div>

        <div class="main-card">
            <div class="input-section">
                <h2 style="margin-bottom: 25px; color: #333; text-align: center;">
                    <i class="fas fa-edit"></i> <span id="formTitle">‡§´‡§∏‡§≤ ‡§ï‡•Ä ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§¶‡•á‡§Ç</span>
                </h2>
                
                <form id="cropForm">
                    <div class="form-group">
                        <label for="soil" id="soilLabel">
                            ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§ï‡§æ ‡§™‡•ç‡§∞‡§ï‡§æ‡§∞
                            <i class="fas fa-info-circle info-tooltip">
                                <span class="tooltip-text" id="soilTooltip">‡§Ö‡§™‡§®‡•á ‡§ñ‡•á‡§§ ‡§ï‡•Ä ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§ï‡§æ ‡§™‡•ç‡§∞‡§ï‡§æ‡§∞ ‡§ö‡•Å‡§®‡•á‡§Ç</span>
                            </i>
                        </label>
                        <select class="form-control" id="soil" required aria-required="true">
                            <option value="" id="soilPlaceholder" disabled selected>‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§ö‡•Å‡§®‡•á‡§Ç</option>
                            <!-- Long list kept as fallback; can be replaced by backend options -->
                            <option value="alluvial">‡§ú‡§≤‡•ã‡§¢‡§º ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä | Alluvial Soil</option>
                            <option value="loamy">‡§¶‡•ã‡§Æ‡§ü ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä | Loamy Soil</option>
                            <option value="clay">‡§ö‡§ø‡§ï‡§®‡•Ä ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä | Clay Soil</option>
                            <option value="well-drained">‡§Ö‡§ö‡•ç‡§õ‡•Ä ‡§ú‡§≤ ‡§®‡§ø‡§ï‡§æ‡§∏‡•Ä ‡§µ‡§æ‡§≤‡•Ä ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä | Well-drained Soil</option>
                            <option value="red">‡§≤‡§æ‡§≤ ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä | Red Soil</option>
                            <option value="clay-loamy">‡§ö‡§ø‡§ï‡§®‡•Ä ‡§¶‡•ã‡§Æ‡§ü ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä | Clay Loamy Soil</option>
                            <option value="sandy-loamy">‡§∞‡•á‡§§‡•Ä‡§≤‡•Ä ‡§¶‡•ã‡§Æ‡§ü ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä | Sandy Loamy Soil</option>
                            <option value="black">‡§ï‡§æ‡§≤‡•Ä ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä | Black Soil</option>
                            <option value="sandy">‡§∞‡•á‡§§‡•Ä‡§≤‡•Ä ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä | Sandy Soil</option>
                            <option value="shallow-black">‡§â‡§•‡§≤‡•Ä ‡§ï‡§æ‡§≤‡•Ä ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä | Shallow Black Soil</option>
                            <option value="black-cotton">‡§ï‡§æ‡§≤‡•Ä ‡§ï‡§™‡§æ‡§∏ ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä | Black Cotton Soil</option>
                            <option value="cotton">‡§ï‡§™‡§æ‡§∏ ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä | Cotton Soil</option>
                            <option value="medium-black">‡§Æ‡§ß‡•ç‡§Ø‡§Æ ‡§ï‡§æ‡§≤‡•Ä ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä | Medium Black Soil</option>
                            <option value="heavy-black">‡§≠‡§æ‡§∞‡•Ä ‡§ï‡§æ‡§≤‡•Ä ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä | Heavy Black Soil</option>
                            <option value="light">‡§π‡§≤‡•ç‡§ï‡•Ä ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä | Light Soil</option>
                            <option value="heavy">‡§≠‡§æ‡§∞‡•Ä ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä | Heavy Soil</option>
                            <option value="deep">‡§ó‡§π‡§∞‡•Ä ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä | Deep Soil</option>
                            <option value="sandy-clay-loamy">‡§∞‡•á‡§§‡•Ä‡§≤‡•Ä ‡§ö‡§ø‡§ï‡§®‡•Ä ‡§¶‡•ã‡§Æ‡§ü ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä | Sandy Clay Loamy Soil</option>
                            <option value="silty-loamy">‡§Æ‡•Å‡§≤‡§æ‡§Ø‡§Æ ‡§¶‡•ã‡§Æ‡§ü ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä | Silty Loamy Soil</option>
                            <option value="salty-clay-loamy">‡§®‡§Æ‡§ï‡•Ä‡§® ‡§ö‡§ø‡§ï‡§®‡•Ä ‡§¶‡•ã‡§Æ‡§ü ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä | Salty Clay Loamy Soil</option>
                            <option value="red-loamy">‡§≤‡§æ‡§≤ ‡§¶‡•ã‡§Æ‡§ü ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä | Red Loamy Soil</option>
                            <option value="brown-loamy">‡§≠‡•Ç‡§∞‡•Ä ‡§¶‡•ã‡§Æ‡§ü ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä | Brown Loamy Soil</option>
                            <option value="laterite">‡§≤‡•á‡§ü‡§∞‡§æ‡§á‡§ü ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä | Laterite Soil</option>
                            <option value="well-drained-loamy">‡§Ö‡§ö‡•ç‡§õ‡•Ä ‡§ú‡§≤ ‡§®‡§ø‡§ï‡§æ‡§∏‡•Ä ‡§µ‡§æ‡§≤‡•Ä ‡§¶‡•ã‡§Æ‡§ü ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä | Well-drained Loamy Soil</option>
                            <option value="light-loamy">‡§π‡§≤‡•ç‡§ï‡•Ä ‡§¶‡•ã‡§Æ‡§ü ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä | Light Loamy Soil</option>
                            <option value="friable">‡§≠‡•Å‡§∞‡§≠‡•Å‡§∞‡•Ä ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä | Friable Soil</option>
                            <option value="well-grained-deep-loamy-moist">‡§Ö‡§ö‡•ç‡§õ‡•Ä ‡§¶‡§æ‡§®‡•á‡§¶‡§æ‡§∞ ‡§ó‡§π‡§∞‡•Ä ‡§¶‡•ã‡§Æ‡§ü ‡§®‡§Æ ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä | Well-grained Deep Loamy Moist Soil</option>
                            <option value="red-lateritic-loamy">‡§≤‡§æ‡§≤ ‡§≤‡•á‡§ü‡§∞‡§æ‡§á‡§ü ‡§¶‡•ã‡§Æ‡§ü ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä | Red Lateritic Loamy Soil</option>
                            <option value="rich-red-loamy">‡§∏‡§Æ‡•É‡§¶‡•ç‡§ß ‡§≤‡§æ‡§≤ ‡§¶‡•ã‡§Æ‡§ü ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä | Rich Red Loamy Soil</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="sown" id="seasonLabel">
                            ‡§¨‡•Å‡§µ‡§æ‡§à ‡§ï‡§æ ‡§Æ‡•å‡§∏‡§Æ
                            <i class="fas fa-info-circle info-tooltip">
                                <span class="tooltip-text" id="seasonTooltip">‡§Ü‡§™ ‡§ï‡§¨ ‡§¨‡•Å‡§µ‡§æ‡§à ‡§ï‡§∞‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç?</span>
                            </i>
                        </label>
                        <select class="form-control" id="sown" required aria-required="true">
                            <option value="" id="seasonPlaceholder" disabled selected>‡§Æ‡•å‡§∏‡§Æ ‡§ö‡•Å‡§®‡•á‡§Ç</option>
                            <option value="kharif">‡§ñ‡§∞‡•Ä‡§´ | Kharif (‡§Æ‡§æ‡§®‡§∏‡•Ç‡§®)</option>
                            <option value="rabi">‡§∞‡§¨‡•Ä | Rabi (‡§∏‡§∞‡•ç‡§¶‡•Ä)</option>
                            <option value="zaid">‡§ú‡§æ‡§Ø‡§¶ | Zaid (‡§ó‡§∞‡•ç‡§Æ‡•Ä)</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="soil_ph" id="phLabel">
                            ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§ï‡§æ pH
                            <span class="bilingual"></span>
                        </label>
                        <!-- removed min/max to allow any float; step="any" allows floats -->
                        <input type="number" class="form-control" id="soil_ph" step="any" placeholder="e.g-7.0" required aria-required="true">
                    </div>

                    <div class="form-row">
                        <div class="form-group">
                            <label for="temp" id="tempLabel">
                                ‡§§‡§æ‡§™‡§Æ‡§æ‡§®
                                <span class="bilingual">(¬∞C)</span>
                            </label>
                            <input type="number" class="form-control" id="temp" step="any" placeholder="e.g-25" required>
                        </div>
                        <div class="form-group">
                            <label for="humidity" id="humidityLabel">
                                ‡§Ü‡§∞‡•ç‡§¶‡•ç‡§∞‡§§‡§æ
                                <span class="bilingual">(%)</span>
                            </label>
                            <input type="number" class="form-control" id="humidity" step="any" placeholder="e.g-60" required>
                        </div>
                    </div>

                    <div class="form-row">
                        <div class="form-group">
                            <label for="nitrogen" id="nitrogenLabel">
                                ‡§®‡§æ‡§á‡§ü‡•ç‡§∞‡•ã‡§ú‡§® (N)
                                <span class="bilingual">(kg/ha)</span>
                            </label>
                            <input type="number" class="form-control" id="nitrogen" step="any" placeholder="e.g-50" required>
                        </div>
                        <div class="form-group">
                            <label for="phosphorus" id="phosphorusLabel">
                                ‡§´‡§æ‡§∏‡•ç‡§´‡•ã‡§∞‡§∏ (P)
                                <span class="bilingual">(kg/ha)</span>
                            </label>
                            <input type="number" class="form-control" id="phosphorus" step="any" placeholder="e.g-25" required>
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="potassium" id="potassiumLabel">
                            ‡§™‡•ã‡§ü‡•à‡§∂‡§ø‡§Ø‡§Æ (K)
                            <span class="bilingual">(kg/ha)</span>
                        </label>
                        <input type="number" class="form-control" id="potassium" step="any" placeholder="e.g-30" required>
                    </div>

                    <button type="submit" id="predictBtnEl" class="predict-btn">
                        <i class="fas fa-magic"></i> <span id="predictBtn">‡§´‡§∏‡§≤ ‡§ï‡•Ä ‡§≠‡§µ‡§ø‡§∑‡•ç‡§Ø‡§µ‡§æ‡§£‡•Ä ‡§ï‡§∞‡•á‡§Ç</span>
                    </button>
                </form>
            </div>

            <div class="output-section">
                <div id="resultsContainer" class="results-container">
                    <div class="empty-state">
                        <i class="fas fa-seedling" aria-hidden="true"></i>
                        <p id="emptyStateText">‡§ï‡•É‡§™‡§Ø‡§æ ‡§µ‡§ø‡§µ‡§∞‡§£ ‡§≠‡§∞‡•á‡§Ç<br><span class="bilingual">Please fill the details to get crop predictions</span></p>
                    </div>
                </div>

                <div id="loadingState" class="loading" aria-hidden="true">
                    <div class="spinner" role="status" aria-label="loading"></div>
                    <p id="loadingText">‡§≠‡§µ‡§ø‡§∑‡•ç‡§Ø‡§µ‡§æ‡§£‡•Ä ‡§π‡•ã ‡§∞‡§π‡•Ä ‡§π‡•à...<br><span class="bilingual">Analyzing your data...</span></p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Language system
        let currentLang = 'hi';
        
        const translations = {
            hi: {
                langText: "English",
                mainTitle: "‡§ï‡§ø‡§∏‡§æ‡§® ‡§Æ‡§ø‡§§‡•ç‡§∞ - Crop Predictor",
                subtitle: "‡§Ü‡§™‡§ï‡•Ä ‡§´‡§∏‡§≤ ‡§ï‡•Ä ‡§≠‡§µ‡§ø‡§∑‡•ç‡§Ø‡§µ‡§æ‡§£‡•Ä ‡§ï‡§∞‡§®‡•á ‡§µ‡§æ‡§≤‡§æ ‡§∏‡•ç‡§Æ‡§æ‡§∞‡•ç‡§ü ‡§∏‡§≤‡§æ‡§π‡§ï‡§æ‡§∞",
                formTitle: "‡§´‡§∏‡§≤ ‡§ï‡•Ä ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§¶‡•á‡§Ç",
                soilLabel: "‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§ï‡§æ ‡§™‡•ç‡§∞‡§ï‡§æ‡§∞",
                soilTooltip: "‡§Ö‡§™‡§®‡•á ‡§ñ‡•á‡§§ ‡§ï‡•Ä ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§ï‡§æ ‡§™‡•ç‡§∞‡§ï‡§æ‡§∞ ‡§ö‡•Å‡§®‡•á‡§Ç",
                soilPlaceholder: "‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§ö‡•Å‡§®‡•á‡§Ç",
                seasonLabel: "‡§¨‡•Å‡§µ‡§æ‡§à ‡§ï‡§æ ‡§Æ‡•å‡§∏‡§Æ",
                seasonTooltip: "‡§Ü‡§™ ‡§ï‡§¨ ‡§¨‡•Å‡§µ‡§æ‡§à ‡§ï‡§∞‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç?",
                seasonPlaceholder: "‡§Æ‡•å‡§∏‡§Æ ‡§ö‡•Å‡§®‡•á‡§Ç",
                phLabel: "‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§ï‡§æ pH",
                tempLabel: "‡§§‡§æ‡§™‡§Æ‡§æ‡§®",
                humidityLabel: "‡§Ü‡§∞‡•ç‡§¶‡•ç‡§∞‡§§‡§æ",
                nitrogenLabel: "‡§®‡§æ‡§á‡§ü‡•ç‡§∞‡•ã‡§ú‡§® (N)",
                phosphorusLabel: "‡§´‡§æ‡§∏‡•ç‡§´‡•ã‡§∞‡§∏ (P)",
                potassiumLabel: "‡§™‡•ã‡§ü‡•à‡§∂‡§ø‡§Ø‡§Æ (K)",
                predictBtn: "‡§´‡§∏‡§≤ ‡§ï‡•Ä ‡§≠‡§µ‡§ø‡§∑‡•ç‡§Ø‡§µ‡§æ‡§£‡•Ä ‡§ï‡§∞‡•á‡§Ç",
                emptyStateText: "‡§ï‡•É‡§™‡§Ø‡§æ ‡§µ‡§ø‡§µ‡§∞‡§£ ‡§≠‡§∞‡•á‡§Ç<br><span class=\"bilingual\">Please fill the details to get crop predictions</span>",
                loadingText: "‡§≠‡§µ‡§ø‡§∑‡•ç‡§Ø‡§µ‡§æ‡§£‡•Ä ‡§π‡•ã ‡§∞‡§π‡•Ä ‡§π‡•à...<br><span class=\"bilingual\">Analyzing your data...</span>",
                recommendedCrop: "‡§∏‡•Å‡§ù‡§æ‡§µ‡§ø‡§§ ‡§´‡§∏‡§≤",
                waterSource: "‡§™‡§æ‡§®‡•Ä ‡§ï‡§æ ‡§∏‡•ç‡§∞‡•ã‡§§",
                cropDuration: "‡§´‡§∏‡§≤ ‡§ï‡•Ä ‡§Ö‡§µ‡§ß‡§ø",
                waterRequired: "‡§™‡§æ‡§®‡•Ä ‡§ï‡•Ä ‡§Ü‡§µ‡§∂‡•ç‡§Ø‡§ï‡§§‡§æ",
                bestSuited: "‡§Ü‡§™‡§ï‡•Ä ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§ï‡•á ‡§Ö‡§®‡•Å‡§ï‡•Ç‡§≤",
                optimalIrrigation: "‡§¨‡•á‡§π‡§§‡§∞ ‡§∏‡§ø‡§Ç‡§ö‡§æ‡§à ‡§ï‡•á ‡§≤‡§ø‡§è",
                sowingToHarvest: "‡§¨‡•Å‡§µ‡§æ‡§à ‡§∏‡•á ‡§ï‡§ü‡§æ‡§à ‡§§‡§ï",
                perKgProduction: "‡§™‡•ç‡§∞‡§§‡§ø ‡§ï‡§ø‡§≤‡•ã ‡§â‡§§‡•ç‡§™‡§æ‡§¶‡§®",
                probabilitySection: "Probability of Growing"
            },
            en: {
                langText: "‡§π‡§ø‡§Ç‡§¶‡•Ä",
                mainTitle: "Farmer Friend - Crop Predictor",
                subtitle: "Your Smart Agricultural Advisor for Crop Prediction",
                formTitle: "Enter Crop Details",
                soilLabel: "Soil Type",
                soilTooltip: "Select the type of soil in your field",
                soilPlaceholder: "Select Soil",
                seasonLabel: "Sowing Season",
                seasonTooltip: "When are you planning to sow?",
                seasonPlaceholder: "Select Season",
                phLabel: "Soil pH",
                tempLabel: "Temperature",
                humidityLabel: "Humidity",
                nitrogenLabel: "Nitrogen (N)",
                phosphorusLabel: "Phosphorus (P)",
                potassiumLabel: "Potassium (K)",
                predictBtn: "Predict Crop",
                emptyStateText: "Please fill the details to get crop predictions",
                loadingText: "Analyzing your data...",
                recommendedCrop: "Recommended Crop",
                waterSource: "Water Source",
                cropDuration: "Crop Duration",
                waterRequired: "Water Required",
                bestSuited: "Best suited for your soil",
                optimalIrrigation: "For optimal irrigation",
                sowingToHarvest: "From sowing to harvest",
                perKgProduction: "Per kg of production",
                probabilitySection: "Probability of Growing"
            }
        };

        function updateLanguage() {
            const lang = currentLang;

            document.getElementById('langText').textContent = translations[lang].langText;
            document.getElementById('mainTitle').textContent = translations[lang].mainTitle;
            document.getElementById('subtitle').textContent = translations[lang].subtitle;
            document.getElementById('formTitle').textContent = translations[lang].formTitle;

            // Update labels & tooltips
            document.getElementById('soilLabel').innerHTML = translations[lang].soilLabel + `\n                <i class="fas fa-info-circle info-tooltip">\n                    <span class="tooltip-text">${translations[lang].soilTooltip}</span>\n                </i>`;

            // Update placeholder text nodes safely
            const soilPlaceholder = document.getElementById('soilPlaceholder');
            if (soilPlaceholder) soilPlaceholder.textContent = translations[lang].soilPlaceholder;

            document.getElementById('seasonLabel').innerHTML = translations[lang].seasonLabel + `\n                <i class="fas fa-info-circle info-tooltip">\n                    <span class="tooltip-text">${translations[lang].seasonTooltip}</span>\n                </i>`;

            const seasonPlaceholder = document.getElementById('seasonPlaceholder');
            if (seasonPlaceholder) seasonPlaceholder.textContent = translations[lang].seasonPlaceholder;

            // removed the hard-coded pH range display per request
            document.getElementById('phLabel').innerHTML = translations[lang].phLabel + '<span class="bilingual"></span>';
            document.getElementById('tempLabel').innerHTML = translations[lang].tempLabel + '<span class="bilingual">(¬∞C)</span>';
            document.getElementById('humidityLabel').innerHTML = translations[lang].humidityLabel + '<span class="bilingual">(%)</span>';
            document.getElementById('nitrogenLabel').innerHTML = translations[lang].nitrogenLabel + '<span class="bilingual">(kg/ha)</span>';
            document.getElementById('phosphorusLabel').innerHTML = translations[lang].phosphorusLabel + '<span class="bilingual">(kg/ha)</span>';
            document.getElementById('potassiumLabel').innerHTML = translations[lang].potassiumLabel + '<span class="bilingual">(kg/ha)</span>';

            document.getElementById('predictBtn').textContent = translations[lang].predictBtn;
            document.getElementById('emptyStateText').innerHTML = translations[lang].emptyStateText;
            document.getElementById('loadingText').innerHTML = translations[lang].loadingText;
        }

        document.getElementById('languageToggle').addEventListener('click', function() {
            currentLang = currentLang === 'hi' ? 'en' : 'hi';
            this.setAttribute('aria-pressed', currentLang === 'en');
            updateLanguage();
        });

        // Sample data to simulate ML model predictions with proper emoji display
        const cropDatabase = {
            'alluvial_kharif_high_ph': {
                crop: 'üåæ ‡§ß‡§æ‡§® | Rice',
                water_source: 'üèûÔ∏è ‡§®‡§¶‡•Ä | River',
                duration: '‚è∞ 120 ‡§¶‡§ø‡§® | 120 days',
                water_required: 'üíß 1200 ‡§≤‡•Ä‡§ü‡§∞/‡§ï‡§ø‡§ó‡•ç‡§∞‡§æ | 1200 L/kg'
            },
            'loamy_rabi_neutral_ph': {
                crop: 'üåæ ‡§ó‡•á‡§π‡•Ç‡§Ç | Wheat',
                water_source: 'üï≥Ô∏è ‡§ï‡•Å‡§Ü‡§Ç | Borewell',
                duration: '‚è∞ 110 ‡§¶‡§ø‡§® | 110 days',
                water_required: 'üíß 800 ‡§≤‡•Ä‡§ü‡§∞/‡§ï‡§ø‡§ó‡•ç‡§∞‡§æ | 800 L/kg'
            },
            'sandy_zaid_neutral_ph': {
                crop: 'üåΩ ‡§Æ‡§ï‡•ç‡§ï‡§æ | Maize',
                water_source: 'üí¶ ‡§°‡•ç‡§∞‡§ø‡§™ ‡§∏‡§ø‡§Ç‡§ö‡§æ‡§à | Drip Irrigation',
                duration: '‚è∞ 95 ‡§¶‡§ø‡§® | 95 days',
                water_required: 'üíß 600 ‡§≤‡•Ä‡§ü‡§∞/‡§ï‡§ø‡§ó‡•ç‡§∞‡§æ | 600 L/kg'
            },
            'black_kharif_high_ph': {
                crop: 'üå∏ ‡§ï‡§™‡§æ‡§∏ | Cotton',
                water_source: 'üåßÔ∏è ‡§¨‡§æ‡§∞‡§ø‡§∂ | Rainwater',
                duration: '‚è∞ 180 ‡§¶‡§ø‡§® | 180 days',
                water_required: 'üíß 1800 ‡§≤‡•Ä‡§ü‡§∞/‡§ï‡§ø‡§ó‡•ç‡§∞‡§æ | 1800 L/kg'
            },
            'red_rabi_low_ph': {
                crop: 'ü´ò ‡§¶‡§æ‡§≤ | Pulses',
                water_source: 'üèä ‡§§‡§æ‡§≤‡§æ‡§¨ | Pond',
                duration: '‚è∞ 85 ‡§¶‡§ø‡§® | 85 days',
                water_required: 'üíß 400 ‡§≤‡•Ä‡§ü‡§∞/‡§ï‡§ø‡§ó‡•ç‡§∞‡§æ | 400 L/kg'
            }
        };

        function getPredictionKey(soil, sown, ph) {
            let phCategory = ph < 6.5 ? 'low_ph' : ph > 7.5 ? 'high_ph' : 'neutral_ph';
            return `${soil}_${sown}_${phCategory}`;
        }

        function simulateMLPrediction(formData) {
            const key = getPredictionKey(formData.soil, formData.sown, formData.soil_ph);
            let prediction = cropDatabase[key];

            if (!prediction) {
                if (formData.sown === 'kharif') {
                    if (formData.soil.includes('black') || formData.soil.includes('cotton')) {
                        prediction = { crop: 'üå∏ ‡§ï‡§™‡§æ‡§∏ | Cotton', water_source: 'üåßÔ∏è ‡§¨‡§æ‡§∞‡§ø‡§∂ | Rainwater', duration: '‚è∞ 180 ‡§¶‡§ø‡§® | 180 days', water_required: 'üíß 1800 ‡§≤‡•Ä‡§ü‡§∞/‡§ï‡§ø‡§ó‡•ç‡§∞‡§æ | 1800 L/kg' };
                    } else if (formData.soil.includes('alluvial') || formData.soil.includes('clay')) {
                        prediction = { crop: 'üåæ ‡§ß‡§æ‡§® | Rice', water_source: 'üèûÔ∏è ‡§®‡§¶‡•Ä | River', duration: '‚è∞ 120 ‡§¶‡§ø‡§® | 120 days', water_required: 'üíß 1200 ‡§≤‡•Ä‡§ü‡§∞/‡§ï‡§ø‡§ó‡•ç‡§∞‡§æ | 1200 L/kg' };
                    } else if (formData.soil.includes('red')) {
                        prediction = { crop: 'üåΩ ‡§ú‡•ç‡§µ‡§æ‡§∞ | Sorghum', water_source: 'üåßÔ∏è ‡§¨‡§æ‡§∞‡§ø‡§∂ | Rainwater', duration: '‚è∞ 110 ‡§¶‡§ø‡§® | 110 days', water_required: 'üíß 650 ‡§≤‡•Ä‡§ü‡§∞/‡§ï‡§ø‡§ó‡•ç‡§∞‡§æ | 650 L/kg' };
                    } else {
                        prediction = { crop: 'üåø ‡§¨‡§æ‡§ú‡§∞‡§æ | Pearl Millet', water_source: 'üåßÔ∏è ‡§¨‡§æ‡§∞‡§ø‡§∂ | Rainwater', duration: '‚è∞ 90 ‡§¶‡§ø‡§® | 90 days', water_required: 'üíß 500 ‡§≤‡•Ä‡§ü‡§∞/‡§ï‡§ø‡§ó‡•ç‡§∞‡§æ | 500 L/kg' };
                    }
                } else if (formData.sown === 'rabi') {
                    if (formData.soil.includes('loamy') || formData.soil.includes('alluvial')) {
                        prediction = { crop: 'üåæ ‡§ó‡•á‡§π‡•Ç‡§Å | Wheat', water_source: 'üï≥Ô∏è ‡§ï‡•Å‡§Ü‡§Ç | Borewell', duration: '‚è∞ 110 ‡§¶‡§ø‡§® | 110 days', water_required: 'üíß 800 ‡§≤‡•Ä‡§ü‡§∞/‡§ï‡§ø‡§ó‡•ç‡§∞‡§æ | 800 L/kg' };
                    } else if (formData.soil.includes('red') || formData.soil.includes('laterite')) {
                        prediction = { crop: 'ü´ò ‡§¶‡§æ‡§≤ | Pulses', water_source: 'üèä ‡§§‡§æ‡§≤‡§æ‡§¨ | Pond', duration: '‚è∞ 85 ‡§¶‡§ø‡§® | 85 days', water_required: 'üíß 400 ‡§≤‡•Ä‡§ü‡§∞/‡§ï‡§ø‡§ó‡•ç‡§∞‡§æ | 400 L/kg' };
                    } else if (formData.soil.includes('black')) {
                        prediction = { crop: 'üå∞ ‡§ö‡§®‡§æ | Chickpea', water_source: 'üí¶ ‡§°‡•ç‡§∞‡§ø‡§™ ‡§∏‡§ø‡§Ç‡§ö‡§æ‡§à | Drip Irrigation', duration: '‚è∞ 100 ‡§¶‡§ø‡§® | 100 days', water_required: 'üíß 350 ‡§≤‡•Ä‡§ü‡§∞/‡§ï‡§ø‡§ó‡•ç‡§∞‡§æ | 350 L/kg' };
                    } else {
                        prediction = { crop: 'üåæ ‡§ú‡•å | Barley', water_source: 'üí¶ ‡§°‡•ç‡§∞‡§ø‡§™ ‡§∏‡§ø‡§Ç‡§ö‡§æ‡§à | Drip Irrigation', duration: '‚è∞ 95 ‡§¶‡§ø‡§® | 95 days', water_required: 'üíß 550 ‡§≤‡•Ä‡§ü‡§∞/‡§ï‡§ø‡§ó‡•ç‡§∞‡§æ | 550 L/kg' };
                    }
                } else { // zaid
                    if (formData.soil.includes('sandy')) {
                        prediction = { crop: 'üåΩ ‡§Æ‡§ï‡•ç‡§ï‡§æ | Maize', water_source: 'üí¶ ‡§°‡•ç‡§∞‡§ø‡§™ ‡§∏‡§ø‡§Ç‡§ö‡§æ‡§à | Drip Irrigation', duration: '‚è∞ 95 ‡§¶‡§ø‡§® | 95 days', water_required: 'üíß 600 ‡§≤‡•Ä‡§ü‡§∞/‡§ï‡§ø‡§ó‡•ç‡§∞‡§æ | 600 L/kg' };
                    } else if (formData.soil.includes('loamy')) {
                        prediction = { crop: 'ü•î ‡§Ü‡§≤‡•Ç | Potato', water_source: 'üö∞ ‡§ü‡•ç‡§Ø‡•Ç‡§¨‡§µ‡•á‡§≤ | Tubewell', duration: '‚è∞ 90 ‡§¶‡§ø‡§® | 90 days', water_required: 'üíß 500 ‡§≤‡•Ä‡§ü‡§∞/‡§ï‡§ø‡§ó‡•ç‡§∞‡§æ | 500 L/kg' };
                    } else if (formData.soil.includes('well-drained')) {
                        prediction = { crop: 'üåª ‡§∏‡•Ç‡§∞‡§ú‡§Æ‡•Å‡§ñ‡•Ä | Sunflower', water_source: 'üíß ‡§∏‡•ç‡§™‡•ç‡§∞‡§ø‡§Ç‡§ï‡§≤‡§∞ | Sprinkler', duration: '‚è∞ 100 ‡§¶‡§ø‡§® | 100 days', water_required: 'üíß 700 ‡§≤‡•Ä‡§ü‡§∞/‡§ï‡§ø‡§ó‡•ç‡§∞‡§æ | 700 L/kg' };
                    } else {
                        prediction = { crop: 'ü•í ‡§ñ‡•Ä‡§∞‡§æ | Cucumber', water_source: 'üí¶ ‡§°‡•ç‡§∞‡§ø‡§™ ‡§∏‡§ø‡§Ç‡§ö‡§æ‡§à | Drip Irrigation', duration: '‚è∞ 60 ‡§¶‡§ø‡§® | 60 days', water_required: 'üíß 400 ‡§≤‡•Ä‡§ü‡§∞/‡§ï‡§ø‡§ó‡•ç‡§∞‡§æ | 400 L/kg' };
                    }
                }
            }

            return prediction;
        }

        // ===== Backend config & helper =====
        const API_CONFIG = {
            baseURL: 'https://crop-sage-uj67.onrender.com', // Replace with your actual backend URL
            endpoints: {
                soilTypes: '/api/soil-types',
                weatherData: '/api/weather',
                cropPrediction: '/api/predict-crop',
                userLocation: '/api/location',
                health: '/health'
            }
        };

        class BackendAPI {
            static async makeRequest(endpoint, options = {}) {
                const url = `${API_CONFIG.baseURL}${endpoint}`;
                const defaultOptions = {
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    }
                };

                try {
                    const response = await fetch(url, { ...defaultOptions, ...options });
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    // Some endpoints may return empty body
                    const text = await response.text();
                    const data = text ? JSON.parse(text) : {};
                    return { success: true, data };
                } catch (error) {
                    console.error('API Error:', error);
                    return { success: false, error: error.message };
                }
            }

            static async checkHealth() {
                // Simple health check to see if backend reachable
                return await this.makeRequest(API_CONFIG.endpoints.health);
            }

            static async getSoilTypes() {
                return await this.makeRequest(API_CONFIG.endpoints.soilTypes);
            }

            // NOTE: getWeatherData and getUserLocation removed/unused (auto-fill weather removed)
            static async predictCrop(formData) {
                return await this.makeRequest(API_CONFIG.endpoints.cropPrediction, {
                    method: 'POST',
                    body: JSON.stringify(formData)
                });
            }
        }

        // ===== UI helpers =====
        function setLoading(isLoading) {
            const results = document.getElementById('resultsContainer');
            const loading = document.getElementById('loadingState');
            const submitBtn = document.getElementById('predictBtnEl');

            if (isLoading) {
                results.style.display = 'none';
                loading.style.display = 'block';
                loading.setAttribute('aria-hidden', 'false');\n                submitBtn.disabled = true;
                submitBtn.style.opacity = '0.7';
                submitBtn.style.cursor = 'not-allowed';
            } else {
                loading.style.display = 'none';
                loading.setAttribute('aria-hidden', 'true');
                submitBtn.disabled = false;
                submitBtn.style.opacity = '1';
                submitBtn.style.cursor = 'pointer';
                results.style.display = 'block';
            }
        }

        // Build a semicircular gauge (SVG) that shows a value 0-100.
        // This gauge is for "Input Confidence" (how many numeric fields are filled).
        function buildSemiGauge(valuePercent, options = {}) {
            // clamp
            const v = Math.max(0, Math.min(100, valuePercent));
            const size = options.size || 400;
            const stroke = options.stroke || 18;
            const radius = (size / 2) - stroke;
            const cx = size / 2;
            const cy = size / 2;
            // angle from -180deg to 0deg (left to right semi)
            const startAngle = Math.PI; // 180deg
            const endAngle = 0;
            const angle = startAngle + ( (endAngle - startAngle) * (v / 100) );

            // compute path for full semicircle (background) and arc for value
            function polarToCartesian(cx, cy, r, angleRad) {
                return {
                    x: cx + r * Math.cos(angleRad),
                    y: cy + r * Math.sin(angleRad)
                };
            }

            // full semicircle path (background)
            const start = polarToCartesian(cx, cy, radius, startAngle);
            const end = polarToCartesian(cx, cy, radius, endAngle);
            const largeArcFlag = 1; // semicircle is always a large arc
            const fullPath = `M ${start.x} ${start.y} A ${radius} ${radius} 0 ${largeArcFlag} 1 ${end.x} ${end.y}`;

            // value arc end point
            const valueEnd = polarToCartesian(cx, cy, radius, angle);
            // determine sweep direction: when drawing from startAngle to angle the sweep-flag is 1
            const sweepFlag = (v === 0) ? 0 : 1;
            // arc length relative to semicircle
            const valuePath = `M ${start.x} ${start.y} A ${radius} ${radius} 0 ${largeArcFlag} ${sweepFlag} ${valueEnd.x} ${valueEnd.y}`;

            // pointer coordinates slightly inside radius
            const pointerLen = radius - stroke - 6;
            const pointerEnd = polarToCartesian(cx, cy, pointerLen, angle);

            // color gradient: red for low, orange mid, green high
            let color = '#f44336'; // red
            if (v >= 70) color = '#4CAF50';
            else if (v >= 40) color = '#FF9800';

            const svg = `
                <svg width="${size}" height="${size/2}" viewBox="0 0 ${size} ${size/2}" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Input confidence gauge">
                    <defs>
                        <linearGradient id="gaugeGrad" x1="0%" y1="0%" x2="100%" y2="0%">
                            <stop offset="0%" stop-color="#f44336"/>
                            <stop offset="50%" stop-color="#FF9800"/>
                            <stop offset="100%" stop-color="#4CAF50"/>
                        </linearGradient>
                    </defs>
                    <g transform="translate(0, ${size/2 - cy})">
                        <!-- background arc -->
                        <path d="${fullPath}" fill="none" stroke="#eee" stroke-width="${stroke}" stroke-linecap="round" />
                        <!-- value arc -->
                        <path d="${valuePath}" fill="none" stroke="url(#gaugeGrad)" stroke-width="${stroke}" stroke-linecap="round" />
                        <!-- pointer -->
                        <line x1="${cx}" y1="${cy}" x2="${pointerEnd.x}" y2="${pointerEnd.y}" stroke="${color}" stroke-width="4" stroke-linecap="round"/>
                        <!-- center circle -->
                        <circle cx="${cx}" cy="${cy}" r="6" fill="${color}" />
                    </g>
                </svg>
            `;
            return svg;
        }

        function displayResults(prediction, inputCompletenessScore = null, derivedProbability = null, npkValues = null) {
            const lang = currentLang;

            // Build the basic result cards (crop, water, duration, water_required)
            let html = `
                <div class="result-card">
                    <div class="result-title">
                        <i class="fas fa-seedling"></i>
                        ${translations[lang].recommendedCrop}
                    </div>
                    <div class="result-value">${prediction.crop}</div>
                    <div class="result-subtitle">${translations[lang].bestSuited}</div>
                </div>
                
                <div class="result-card">
                    <div class="result-title">
                        <i class="fas fa-tint"></i>
                        ${translations[lang].waterSource}
                    </div>
                    <div class="result-value">${prediction.water_source}</div>
                    <div class="result-subtitle">${translations[lang].optimalIrrigation}</div>
                </div>
                
                <div class="result-card">
                    <div class="result-title">
                        <i class="fas fa-calendar-alt"></i>
                        ${translations[lang].cropDuration}
                    </div>
                    <div class="result-value">${prediction.duration}</div>
                    <div class="result-subtitle">${translations[lang].sowingToHarvest}</div>
                </div>
                
                <div class="result-card">
                    <div class="result-title">
                        <i class="fas fa-water"></i>
                        ${translations[lang].waterRequired}
                    </div>
                    <div class="result-value">${prediction.water_required}</div>
                    <div class="result-subtitle">${translations[lang].perKgProduction}</div>
                </div>
            `;

            // Insert gauge + Probability block
            if (inputCompletenessScore === null) {
                // default to 0 if not supplied
                inputCompletenessScore = 0;
            }

            const probabilityPercent = prediction.confidence ? Math.round(prediction.confidence * 100) : (derivedProbability !== null ? Math.round(derivedProbability) : null);

            // Compose gauge section
            html += `
                <div class="result-card" style="border-left-color: #9C27B0;">
                    <div class="result-title">
                        <i class="fas fa-tachometer-alt"></i>
                        Input Confidence
                    </div>
                    <div class="gauge-wrapper" id="gaugeWrapper">
                        ${buildSemiGauge(inputCompletenessScore, { size: 360 })}
                        <div class="gauge-labels">
                            <span>Low</span>
                            <span>Medium</span>
                            <span>High</span>
                        </div>
                    </div>
                    <div class="result-subtitle">Shows how complete and consistent your numeric inputs are</div>
                </div>
            `;

            // Probability of Growing section
            html += `
                <div class="result-card probability-card" style="border-left-color: #3F51B5;">
                    <div class="result-title">
                        <i class="fas fa-percentage"></i>
                        ${translations[lang].probabilitySection}
                    </div>
                    <div class="result-value" id="probValue">${probabilityPercent !== null ? probabilityPercent + '%' : '‚Äî'}</div>
                    <div class="result-subtitle" id="probSubtitle">${probabilityPercent !== null ? (probabilityPercent >= 70 ? 'High likelihood' : (probabilityPercent >= 40 ? 'Moderate likelihood' : 'Low likelihood')) : 'Probability not available'}</div>
                </div>
            `;

            // NPK gauges: show three semicircular gauges for Nitrogen, Phosphorus, Potassium
            // npkValues expected as { nitrogen, phosphorus, potassium } with numeric values
            if (!npkValues) {
                npkValues = { nitrogen: null, phosphorus: null, potassium: null };
            }

            // get ideal ranges based on predicted crop
            const ideal = getIdealNPK(prediction.crop || '');

            function makeNPKGaugeHtml(label, value, idealRange) {
                const provided = (typeof value === 'number' && Number.isFinite(value));
                let percent = 0;
                let statusText = 'Not provided';
                if (provided) {
                    percent = computeNPKPercent(value, idealRange.min, idealRange.max);
                    // status text
                    if (percent < 40) statusText = 'Low';
                    else if (percent <= 60) statusText = 'Near ideal';
                    else statusText = 'High';
                }
                const diffText = provided ? `${value} kg/ha (ideal ${idealRange.min}-${idealRange.max})` : '‚Äî';
                return `
                    <div class="npk-gauge">
                        <div style="font-weight:600; margin-bottom:6px;">${label}</div>
                        ${buildSemiGauge(percent, { size: 260, stroke: 14 })}
                        <div class="npk-meta">${diffText}<br/><strong>${statusText}</strong></div>
                    </div>
                `;
            }

            html += `
                <div class="result-card" style="border-left-color: #43A047;">
                    <div class="result-title">
                        <i class="fas fa-flask"></i>
                        N-P-K Levels (relative to ${prediction.crop})
                    </div>
                    <div class="npk-gauges">
                        ${makeNPKGaugeHtml('Nitrogen (N)', npkValues.nitrogen, ideal.N)}
                        ${makeNPKGaugeHtml('Phosphorus (P)', npkValues.phosphorus, ideal.P)}
                        ${makeNPKGaugeHtml('Potassium (K)', npkValues.potassium, ideal.K)}
                    </div>
                    <div class="result-subtitle">Gauges indicate whether each nutrient is low / near ideal / high for the predicted crop.</div>
                </div>
            `;

            // If prediction.confidence exists, also show it explicitly in a card
            if (prediction.confidence) {
                html += `
                <div class="result-card" style="border-left-color: #2196F3;">
                    <div class="result-title">
                        <i class="fas fa-chart-line"></i>
                        Prediction Confidence
                    </div>
                    <div class="result-value">${Math.round(prediction.confidence * 100)}%</div>
                    <div class="result-subtitle">Model accuracy for this prediction</div>
                </div>
                `;
            }

            document.getElementById('resultsContainer').innerHTML = html;
        }

        // Compute a 0-100 percent for N/P/K relative to ideal range
        // 0 => very low, ~50 => ideal mid, 100 => very high
        function computeNPKPercent(value, idealMin, idealMax) {
            if (!Number.isFinite(value) || !Number.isFinite(idealMin) || !Number.isFinite(idealMax) || idealMax <= idealMin) {
                return 0;
            }
            // If below idealMin -> scale 0..50
            if (value <= idealMin) {
                const pct = (value / idealMin) * 50;
                return Math.max(0, Math.min(50, Math.round(pct)));
            }
            // If within ideal range -> 40..60 mapped to 35..65 produce tighter near-ideal band
            if (value > idealMin && value <= idealMax) {
                const ratioWithin = (value - idealMin) / (idealMax - idealMin);
                const pct = 40 + ratioWithin * 20; // 40..60
                return Math.round(pct);
            }
            // If above idealMax -> scale 60..100
            if (value > idealMax) {
                // relative above
                const aboveRatio = (value - idealMax) / Math.max(1, idealMax);
                const pct = 60 + Math.min(40, aboveRatio * 40); // cap at 100
                return Math.max(60, Math.min(100, Math.round(pct)));
            }
            return 50;
        }

        // Simple mapping of crop name to ideal NPK ranges (kg/ha).
        // These are heuristic defaults used only to generate the gauge - tweak as needed.
        function getIdealNPK(cropName) {
            const name = (cropName || '').toLowerCase();
            // default baseline
            const defaultRange = { N: {min: 20, max: 80}, P: {min: 10, max: 40}, K: {min: 20, max: 80} };

            // Specific crops heuristics (common broad ranges)
            const map = [
                { keywords: ['rice', '‡§ß‡§æ‡§®'], ranges: { N: {min: 60, max: 140}, P: {min: 20, max: 60}, K: {min: 40, max: 120} } },
                { keywords: ['wheat', '‡§ó‡•á‡§π‡•Ç‡§Å', '‡§ó‡•á‡§π‡•Ç'], ranges: { N: {min: 80, max: 160}, P: {min: 30, max: 70}, K: {min: 30, max: 80} } },
                { keywords: ['maize', '‡§Æ‡§ï‡•ç‡§ï‡§æ', 'corn'], ranges: { N: {min: 80, max: 200}, P: {min: 30, max: 80}, K: {min: 40, max: 120} } },
                { keywords: ['cotton', '‡§ï‡§™‡§æ‡§∏'], ranges: { N: {min: 60, max: 120}, P: {min: 30, max: 60}, K: {min: 40, max: 120} } },
                { keywords: ['pulses', '‡§¶‡§æ‡§≤', 'lentil', 'chickpea', '‡§ö‡§®‡§æ'], ranges: { N: {min: 10, max: 40}, P: {min: 20, max: 50}, K: {min: 20, max: 60} } },
                { keywords: ['sorghum', '‡§ú‡•ç‡§µ‡§æ‡§∞', 'pearl millet', 'bajra', '‡§¨‡§æ‡§ú‡§∞‡§æ'], ranges: { N: {min: 30, max: 80}, P: {min: 15, max: 40}, K: {min: 20, max: 80} } },
                { keywords: ['potato', '‡§Ü‡§≤‡•Ç'], ranges: { N: {min: 120, max: 250}, P: {min: 40, max: 100}, K: {min: 180, max: 300} } },
                { keywords: ['sunflower', '‡§∏‡•Ç‡§∞‡§ú‡§Æ‡•Å‡§ñ‡•Ä'], ranges: { N: {min: 40, max: 120}, P: {min: 40, max: 80}, K: {min: 80, max: 160} } },
                { keywords: ['cucumber', '‡§ñ‡•Ä‡§∞‡§æ'], ranges: { N: {min: 60, max: 150}, P: {min: 40, max: 80}, K: {min: 60, max: 150} } },
                { keywords: ['barley', '‡§ú‡•å'], ranges: { N: {min: 50, max: 120}, P: {min: 25, max: 60}, K: {min: 30, max: 80} } }
            ];

            for (const item of map) {
                for (const kw of item.keywords) {
                    if (name.includes(kw)) {
                        return item.ranges;
                    }
                }
            }
            return defaultRange;
        }

        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${type === 'success' ? '#4CAF50' : type === 'warning' ? '#FF9800' : '#2196F3'};
                color: white;
                padding: 15px 20px;
                border-radius: 10px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                z-index: 1000;
                transform: translateX(400px);
                transition: transform 0.3s ease;
                font-weight: 500;
                max-width: 300px;
            `;
            notification.textContent = message;

            document.body.appendChild(notification);

            // Animate in
            setTimeout(() => {
                notification.style.transform = 'translateX(0)';
            }, 100);

            // Remove after 4 seconds
            setTimeout(() => {
                notification.style.transform = 'translateX(400px)';
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 4000);
        }

        function showErrorMessage(message) {
            document.getElementById('resultsContainer').innerHTML = `
                <div class="result-card" style="border-left-color: #f44336;">
                    <div class="result-title" style="color: #f44336;">
                        <i class="fas fa-exclamation-triangle"></i>
                        Error
                    </div>
                    <div class="result-value" style="color: #f44336; font-size: 1.2rem;">${message}</div>
                    <div class="result-subtitle">Please check your connection and try again</div>
                </div>
            `;
        }

        // Load soil types from backend (if available) - kept but optional fallback exists
        async function loadSoilTypes() {
            try {
                const soilResponse = await BackendAPI.getSoilTypes();
                if (soilResponse.success && Array.isArray(soilResponse.data) && soilResponse.data.length > 0) {
                    const soilSelect = document.getElementById('soil');
                    const placeholder = soilSelect.querySelector('#soilPlaceholder');

                    // Clear existing options but keep placeholder element
                    soilSelect.innerHTML = '';
                    soilSelect.appendChild(placeholder);

                    soilResponse.data.forEach(soil => {
                        const option = document.createElement('option');
                        option.value = soil.code || soil.id || (soil.name_en ? soil.name_en.toLowerCase().replace(/\s+/g, '-') : (soil.name || '').toLowerCase().replace(/\s+/g, '-'));
                        option.textContent = `${soil.name_hi || soil.name} | ${soil.name_en || soil.name}`;
                        soilSelect.appendChild(option);
                    });
                }
            } catch (error) {
                console.error('Failed to load soil types from backend:', error);
                // Keep existing hardcoded options as fallback
            }
        }

        // Form handling using backend when available, fallback to local simulate
        async function handleFormSubmission(formData) {
            try {
                setLoading(true);

                const backendResponse = await BackendAPI.predictCrop({
                    ...formData,
                    timestamp: new Date().toISOString(),
                    userAgent: navigator.userAgent,
                    language: currentLang
                });

                let prediction;
                if (backendResponse.success && backendResponse.data && Object.keys(backendResponse.data).length > 0) {
                    prediction = backendResponse.data;
                } else {
                    prediction = simulateMLPrediction(formData);
                }

                // Compute input completeness score (how many numeric fields provided)
                const numericFields = ['soil_ph', 'temp', 'humidity', 'nitrogen', 'phosphorus', 'potassium'];
                let filledCount = 0;
                numericFields.forEach(k => {
                    const v = formData[k];
                    if (typeof v === 'number' && Number.isFinite(v)) filledCount++;
                });
                const completenessScore = Math.round((filledCount / numericFields.length) * 100);

                // Compute a simple derived probability:
                // If backend returned confidence, use it. Otherwise use completeness heuristic:
                // completeness >= 80 => high (75%), between 50-79 => moderate (55%), else 30%
                let derivedProb = null;
                if (!prediction.confidence) {
                    if (completenessScore >= 80) derivedProb = 75;
                    else if (completenessScore >= 50) derivedProb = 55;
                    else derivedProb = 30;
                } else {
                    derivedProb = Math.round(prediction.confidence * 100);
                }

                setLoading(false);
                // Pass NPK values to displayResults so gauges can be rendered
                await displayResults(prediction, completenessScore, derivedProb, {
                    nitrogen: formData.nitrogen,
                    phosphorus: formData.phosphorus,
                    potassium: formData.potassium
                });
            } catch (error) {
                console.error('Prediction error:', error);
                setLoading(false);
                showErrorMessage('Unable to get prediction. Please try again.');
            }
        }

        // Prevent duplicate submit handlers and wire the single handler
        document.getElementById('cropForm').addEventListener('submit', async function(e) {
            e.preventDefault();

            const soil = document.getElementById('soil').value;
            const sown = document.getElementById('sown').value;
            const soil_ph = parseFloat(document.getElementById('soil_ph').value);
            const temp = parseFloat(document.getElementById('temp').value);
            const humidity = parseFloat(document.getElementById('humidity').value);
            const nitrogen = parseFloat(document.getElementById('nitrogen').value);
            const phosphorus = parseFloat(document.getElementById('phosphorus').value);
            const potassium = parseFloat(document.getElementById('potassium').value);

            // Basic client-side validation
            if (!soil || !sown || isNaN(soil_ph) || isNaN(temp) || isNaN(humidity)) {
                showNotification('‡§ï‡•É‡§™‡§Ø‡§æ ‡§∏‡§≠‡•Ä ‡§Ü‡§µ‡§∂‡•ç‡§Ø‡§ï ‡§´‡§º‡•Ä‡§≤‡•ç‡§° ‡§≠‡§∞‡•á‡§Ç / Please fill all required fields', 'warning');
                return;
            }

            const formData = { soil, sown, soil_ph, temp, humidity, nitrogen, phosphorus, potassium };
            await handleFormSubmission(formData);
        });

        // Small focus/blur animations for inputs
        const inputs = document.querySelectorAll('.form-control');
        inputs.forEach(input => {
            input.addEventListener('focus', function() {
                this.style.transform = 'scale(1.02)';
            });
            input.addEventListener('blur', function() {
                this.style.transform = 'scale(1)';
            });
        });

        // Initialize the application
        async function initializeApp() {
            updateLanguage();

            try {
                const healthCheck = await BackendAPI.checkHealth();
                if (healthCheck.success) {
                    showNotification('‚úÖ Connected to Crop Sage AI Backend!', 'success');
                    await loadSoilTypes();
                } else {
                    showNotification('‚ö†Ô∏è Backend offline - using local features', 'warning');
                }
            } catch (error) {
                console.error('Health check failed:', error);
                showNotification('üîÑ Working in offline mode', 'info');
            }
        }

        // ----------------------------
        // Inject semicircular analog meter (no changes elsewhere)
        // This IIFE adds CSS and an analog semicircular clock into #resultsContainer.
        // ----------------------------
        (function injectSemiAnalog() {
          const css = `
          /* semicircular analog watch styles */
          .analog-semi-container {
            width: 100%;
            display:flex;
            justify-content:center;
            margin-bottom: 16px;
          }
          .analog-semi {
            width: 320px;
            max-width: 92%;
            height: 160px; /* half of width for semicircle */
            position: relative;
            pointer-events: none;
          }
          .analog-semi svg { display:block; width:100%; height:100%; }
          .analog-center {
            position:absolute;
            left:50%;
            bottom:0;
            transform: translateX(-50%);
            width:12px;
            height:12px;
            border-radius:50%;
            background:#333;
            z-index:5;
            box-shadow: 0 0 6px rgba(0,0,0,0.2);
          }
          .clock-hand {
            position:absolute;
            left:50%;
            bottom:8px; /* little offset so pivot is visible */
            transform-origin: 50% 100%;
            transform: translateX(-50%) rotate(0deg);
            z-index:4;
            pointer-events:none;
          }
          .hand-hour { width:4px; height:52px; background:#222; border-radius:4px; }
          .hand-minute { width:3px; height:74px; background:#111; border-radius:3px; }
          .hand-second { width:2px; height:86px; background:#e53935; border-radius:2px; opacity:0.9; }

          /* small tick marks along semicircle */
          .tick-container {
            position:absolute;
            left:0; right:0;
            bottom:0;
            height:100%;
            pointer-events:none;
          }
          .tick {
            position:absolute;
            left:50%;
            bottom:6px;
            width:2px;
            background:#666;
            transform-origin: 50% 100%;
            opacity:0.85;
          }
          `;

          const style = document.createElement('style');
          style.textContent = css;
          document.head.appendChild(style);

          const container = document.createElement('div');
          container.className = 'analog-semi-container';
          container.setAttribute('aria-hidden','false');
          container.setAttribute('role','img');
          container.setAttribute('aria-label','Semicircular analog clock showing current time');

          const semi = document.createElement('div');
          semi.className = 'analog-semi';
          semi.setAttribute('id','analogSemiClock');

          semi.innerHTML = `
            <svg viewBox="0 0 320 160" preserveAspectRatio="xMidYMid meet" aria-hidden="true">
              <defs>
                <linearGradient id="semiGrad" x1="0%" y1="0%" x2="100%" y2="0%">
                  <stop offset="0%" stop-color="#667eea" stop-opacity="0.95"/>
                  <stop offset="100%" stop-color="#764ba2" stop-opacity="0.95"/>
                </linearGradient>
              </defs>
              <!-- background semicircle -->
              <path d="M 10 150 A 150 150 0 0 1 310 150" fill="none" stroke="#eee" stroke-width="18" stroke-linecap="round" />
              <path d="M 18 150 A 132 132 0 0 1 302 150" fill="none" stroke="url(#semiGrad)" stroke-width="12" stroke-linecap="round" opacity="0.95"/>
              <!-- optional small arc markers -->
              <g id="tickMarks"></g>
            </svg>
            <div class="tick-container" aria-hidden="true"></div>
            <div class="clock-hand hand-hour" id="handHour" style="transform: translateX(-50%) rotate(0deg);"></div>
            <div class="clock-hand hand-minute" id="handMinute" style="transform: translateX(-50%) rotate(0deg);"></div>
            <div class="clock-hand hand-second" id="handSecond" style="transform: translateX(-50%) rotate(0deg);"></div>
            <div class="analog-center" aria-hidden="true"></div>
          `;

          container.appendChild(semi);

          const resultsEl = document.getElementById('resultsContainer');
          if (resultsEl) {
            resultsEl.insertBefore(container, resultsEl.firstChild);
          } else {
            const outSec = document.querySelector('.output-section');
            if (outSec) outSec.insertBefore(container, outSec.firstChild);
          }

          const tickContainer = semi.querySelector('.tick-container');
          const tickCount = 13; // ticks at each hour across semicircle (e.g., 0..12)
          for (let i = 0; i < tickCount; i++) {
            const tick = document.createElement('div');
            tick.className = 'tick';
            const fraction = i / (tickCount - 1); // 0..1
            const angleDeg = 180 - (fraction * 180);
            tick.style.height = (i % 3 === 0) ? '14px' : '8px';
            tick.style.transform = `translateX(-50%) rotate(${angleDeg}deg) translateY(-${(semi.clientHeight/2 - 8)}px)`;
            tickContainer.appendChild(tick);
          }

          function timeToAngles(date) {
            const h = date.getHours() % 12;
            const m = date.getMinutes();
            const s = date.getSeconds();
            const hourAngle = (h + m / 60 + s / 3600) * 30;
            const minuteAngle = (m + s / 60) * 6;
            const secondAngle = s * 6;
            return { hourAngle, minuteAngle, secondAngle };
          }

          function applyHandTransforms(date) {
            const { hourAngle, minuteAngle, secondAngle } = timeToAngles(date);
            const hourHand = document.getElementById('handHour');
            const minHand = document.getElementById('handMinute');
            const secHand = document.getElementById('handSecond');

            if (hourHand) hourHand.style.transform = `translateX(-50%) rotate(${hourAngle - 90}deg)`;
            if (minHand) minHand.style.transform = `translateX(-50%) rotate(${minuteAngle - 90}deg)`;
            if (secHand) secHand.style.transform = `translateX(-50%) rotate(${secondAngle - 90}deg)`;
          }

          function adjustHandSizes() {
            const semiEl = document.getElementById('analogSemiClock');
            if (!semiEl) return;
            const w = semiEl.clientWidth;
            const hour = document.getElementById('handHour');
            const minute = document.getElementById('handMinute');
            const second = document.getElementById('handSecond');
            if (hour) {
              hour.style.height = Math.round(w * 0.16) + 'px';
              hour.style.width = Math.max(3, Math.round(w * 0.012)) + 'px';
            }
            if (minute) {
              minute.style.height = Math.round(w * 0.22) + 'px';
              minute.style.width = Math.max(2, Math.round(w * 0.008)) + 'px';
            }
            if (second) {
              second.style.height = Math.round(w * 0.26) + 'px';
              second.style.width = Math.max(2, Math.round(w * 0.006)) + 'px';
            }
          }

          adjustHandSizes();
          let rTO;
          window.addEventListener('resize', () => {
            clearTimeout(rTO);
            rTO = setTimeout(() => {
              adjustHandSizes();
            }, 120);
          });

          function tick() {
            const now = new Date();
            applyHandTransforms(now);
            const msToNext = 1000 - (now.getMilliseconds());
            setTimeout(tick, msToNext);
          }
          tick();

        })();

        // Finally initialize app when DOM ready
        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>

